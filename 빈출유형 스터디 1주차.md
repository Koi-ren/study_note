# 개념 문제

## 1. DFS 구현 방식 비교 (재귀 호출 vs 명시적 스택)

- **재귀 호출**:
    - **장점**: 코드가 간결하고 직관적, 스택 관리 필요 없음(시스템 호출 스택 활용)
    - **단점**: 깊은 그래프에서 스택 오버플로우 발생 가능, 메모리 사용량 제어 어려움
- **명시적 스택**:
    - **장점**: 메모리 사용량 직접 제어 가능, 스택 오버플로우 위험 없음, 깊은 그래프 처리 유리
    - **단점**: 코드가 복잡하고 구현 시간 더 걸림, 스택 관리 직접 해야 함
- **비교**: 재귀는 간단한 문제에 적합, 스택은 대규모 데이터나 안정성이 중요한 경우 유리

## 2. 방향 그래프에서 사이클 판별 (DFS 활용)

- **알고리즘**:
    1. 각 노드에 대해 방문 상태를 기록(미방문, 방문 중, 방문 완료)
    2. DFS로 그래프 탐색 시작:
        - 노드를 방문 중으로 표시
        - 인접 노드 탐색 중 이미 "방문 중"인 노드 만나면 사이클 존재
        - 탐색 끝나면 "방문 완료"로 표시
    3. 모든 노드에 대해 반복, 사이클 여부 확인
- **핵심**: "방문 중" 상태에서 같은 노드 재방문 시 사이클 판별
- **구체적 예**: A → B → C → A 탐색 중 C에서 A로 가는 간선 발견 시 사이클 확인

## 3. 재귀 DFS에서 백트래킹 동작 설명

- **동작 방식**: 재귀 호출로 노드를 방문하며 더 이상 갈 곳 없으면 최근 노드로 돌아감(호출 스택 pop)
- **예시**:
    - 그래프: A → B → D, A → C
    - 과정:
        1. A 방문 → B 방문 → D 방문
        2. D에서 갈 곳 없음 → B로 백트래킹
        3. B에서 더 탐색할 곳 없음 → A로 백트래킹
        4. A에서 C 방문 후 종료
    - **결과**: 백트래킹은 호출 스택을 통해 자연스럽게 이전 노드로 복귀하며 경로 탐색

## 개념 문제 참고 블로그: 
- [[Data Structure / Algorithms] Cycle Detection in Graphs (사이클 판별)](https://velog.io/@jeon0976/Data-Structure-Algorithms-Cycle-Detection-in-Graphs-%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%8C%90%EB%B3%84)
- [[알고리즘] DFS/BFS/재귀함수/Stack](https://velog.io/@sugenius77/DFSBFS%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98Stack)

# 풀어볼 문제

## 1. 깊이 우선 탐색 문제(몸풀이)
## 2. 네트워크(프로그래머스)

### **문제:** 
[코딩테스트 연습 - 네트워크 | 프로그래머스 스쿨](https://school.programmers.co.kr/learn/courses/30/lessons/43162)
### **2번 문제 해결 핵심 정리**

#### **1. 문제 이해**

- **목표**: 주어진 컴퓨터 연결 정보에서 독립된 네트워크 개수를 구함
- **입력**:
    - n: 컴퓨터 개수 (1 ≤ n ≤ 200)
    - computers: n × n 크기의 2차원 배열, computers[i][j] = 1이면 i와 j가 연결됨
- **특징**:
    - computers[i][i] = 1 (자기 자신은 항상 연결)
    - 연결은 양방향(무방향 그래프)으로 간주 가능

#### **2. 해결 아이디어**

- **그래프 탐색**: 각 컴퓨터를 노드로, 연결을 간선으로 간주해 그래프를 구성
- **네트워크 식별**: 연결된 컴퓨터 그룹(네트워크)을 탐색으로 묶고, 독립된 그룹 수를 셈
- **알고리즘 선택**:
    - DFS: 한 노드에서 시작해 연결된 모든 노드를 재귀로 방문
    - BFS: 큐를 활용해 인접 노드를 순차적으로 방문
    - 둘 중 하나 선택 가능(여기선 DFS로 설명)

#### **3. 핵심 로직**

1. **방문 여부 체크**: 각 컴퓨터의 방문 상태를 기록할 배열(visited) 생성
2. **DFS 구현**:
    - 시작 노드 방문 표시 후, 연결된 모든 노드를 재귀적으로 탐색
    - 한 네트워크 내 모든 노드 방문 완료 시 종료
3. **네트워크 개수 세기**:
    - 방문하지 않은 노드를 발견할 때마다 DFS 실행 → 네트워크 수 증가
4. **반복**: 모든 노드 방문할 때까지 진행

#### **4. 입출력 예 분석**

- **예제 1**: n = 3, computers = `[[1, 1, 0], [1, 1, 0], [0, 0, 1]]
    - 네트워크 1: 0번 ↔ 1번
    - 네트워크 2: 2번
    - 결과: 2개
- **예제 2**: n = 3, computers = `[[1, 1, 0], [1, 1, 1], [0, 1, 1]]
    - 네트워크 1: 0번 ↔ 1번 ↔ 2번
    - 결과: 1개

#### **5. 코드 설계**

- **변수**:
    - visited: 방문 여부 배열 (초기값: False)
    - count: 네트워크 개수
- **DFS 함수**:
    - 입력: 현재 노드, computers, visited
    - 동작: 연결된노드 탐색 후 방문 표시
- **메인 로직**:
    - 모든 노드 순회하며 방문 안 된 노드 발견 시 DFS 호출, count 증가

## 3. 양과 늑대(프로그래머스)
### **문제:** 
[코딩테스트 연습 - 양과 늑대 | 프로그래머스 스쿨](https://school.programmers.co.kr/learn/courses/30/lessons/92343)