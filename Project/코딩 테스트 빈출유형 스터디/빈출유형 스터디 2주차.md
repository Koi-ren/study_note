# 개념 문제

## 1. BFS(너비 우선 탐색) 알고리즘의 작동 원리와 자료구조

- **작동 원리**:
    - 시작 노드에서 출발해 인접 노드를 모두 탐색한 뒤, 다음 단계의 인접 노드를 순차적으로 탐색
    - 레벨 단위로 탐색 진행(즉, 시작 노드로부터 거리가 가까운 노드부터 방문)
    - 탐색 과정:
        1. 시작 노드를 큐에 삽입하고 방문 표시
        2. 큐에서 노드를 꺼내 그 인접 노드를 방문
        3. 방문하지 않은 인접 노드를 큐에 삽입하고 방문 표시
        4. 큐가 빌 때까지 반복.
- **사용 자료구조**: 큐(Queue)
    - 이유: BFS는 먼저 방문한 노드의 인접 노드를 우선 처리해야 하므로, 선입선출 방식의 큐가 적합
	    - 큐는 노드를 레벨 순서대로 유지하며, 새로운 노드를 뒤에 추가하고 오래된 노드를 앞에서 꺼내 처리
    - 추가적으로, 방문 여부를 확인하기 위해 집합(Set)이나 배열을 사용
- **왜 큐인가?**: 큐는 노드의 방문 순서를 시작점에서 가까운 순서대로 보장하며, 스택(DFS에서 사용)과 달리 깊이 우선이 아닌 너비 우선 탐색을 가능하게 함

## 2. BFS와 DFS의 차이점 및 적합한 문제

- **차이점**:
    - **탐색 방식**:
        - BFS: 너비 우선 탐색. 같은 레벨의 노드를 모두 탐색 후 다음 레벨로 이동
	        - 큐 사용
        - DFS: 깊이 우선 탐색. 한 경로를 끝까지 탐색 후 다른 경로로 이동 
	        - 스택 또는 재귀 사용
	    - ![[빈출유형 스터디 2주차-20250412.png]]
    - **메모리 사용**:
        - BFS: 큐에 같은 레벨의 노드를 저장하므로, 넓은 그래프에서 메모리 사용량이 많을 수 있음
        - DFS: 스택(또는 재귀 호출 스택)에 현재 경로만 저장하므로, 깊은 그래프에서 메모리 효율적
    - **완전성**:
        - BFS: 유한 그래프에서 목표 노드를 반드시 찾음(최단 경로 보장)
        - DFS: 무한 그래프나 사이클이 있는 경우 목표를 놓칠 가능성 있음
- **적합한 문제**:
    - **BFS**:
        - 적합: 최단 경로 찾기, 레벨 기반 탐색
        - 예시: 미로에서 시작점에서 출구까지의 최단 경로 찾기
	        1. 다익스트라 알고리즘의 기초 형태 
		        -  네트워크에서 특정 노드까지의 최소 홉 수 계산
	        2. 소셜 네트워크에서 친구 관계 레벨 분석
    - **DFS**:
        - 적합: 모든 경로 탐색, 연결성 확인, 백트래킹
        - 그래프에서 사이클 존재 여부 판별
	        1. 방문 중 노드 재방문 시 사이클 확인
	        2. 스도쿠나 N-퀸 문제처럼 모든 가능한 해를 탐색하는 경우
- **비교**:

| BFS               | DFS                        |
| ----------------- | -------------------------- |
| 최단 경로가 중요한 문제에 적합 | 메모리 효율적이고 완전 탐색이 필요한 경우 유리 |


## 3. BFS 시간 복잡도와 그래프 형태의 영향

- **시간 복잡도**: BFS의 시간 복잡도는 O(V + E)
    - V: 정점(Vertex) 수
	    - 각 정점을 한 번씩 방문
    - E: 간선(Edge) 수 
	    - 각 간선을 한 번씩 확인
    - 큐 연산(삽입/삭제)은 O(1)이므로, 전체 복잡도는 정점과 간선 처리에 의해 결정
- **그래프 형태의 영향**:
    - **밀집 그래프(Dense Graph)**:
        - 특징: 간선 수가 정점 수의 제곱에 가까움(E ≈ V², 예: 완전 그래프)
        - 영향: 간선 확인 비용이 지배적. 시간 복잡도는 O(V²)에 가까워짐
        - 예시: 인접 행렬로 표현된 그래프에서, 각 정점의 인접 노드 확인 시 O(V) 걸리므로, 총 O(V²)
        - 실제 수행 시간: 간선이 많아 큐에 삽입되는 노드 수가 많고, 각 노드의 인접 리스트 탐색에 시간이 더 걸림
    - **희소 그래프(Sparse Graph)**:
        - 특징: 간선 수가 정점 수에 비해 적음(E ≈ V, 예: 트리나 격자 그래프)
        - 영향: 정점과 간선 수가 비슷한 비율로 기여. 시간 복잡도는 O(V + E) ≈ O(V)
        - 예시: 인접 리스트로 표현된 그래프에서, 각 정점의 인접 노드 확인 비용이 적음
        - 실제 수행 시간: 간선이 적어 큐에 삽입되는 노드 수가 적고, 인접 노드 탐색이 빠름
- **결론**: 밀집 그래프에서는 간선 처리로 인해 실제 수행 시간이 증가하며, 희소 그래프에서는 정점 처리 비중이 커 상대적으로 빠름. 그래프 표현 방식(인접 리스트 vs 인접 행렬)도 수행 시간에 큰 영향을 미침(인접 리스트는 희소 그래프에서 효율적, 인접 행렬은 밀집 그래프에서 유리)

# 풀어볼 문제
## 1. 너비 우선 탐색 순회
...
## 게임 맵 최단거리
### **문제:**

[코딩테스트 연습 - 게임 맵 최단거리 | 프로그래머스 스쿨](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

### **2번 문제 해결 핵심 정리**

#### **1. 문제 이해**

- **목표**: 주어진 게임 맵에서 캐릭터가 시작점(1,1)에서 상대 팀 진영(n,m)까지의 최단 경로(칸 수)를 구함 
	- 경로가 없으면 -1 반환
- **입력**:
    - maps: n × m 크기의 2차원 배열 (1 ≤ n, m ≤ 100)
    - maps[i][j] = 0은 벽, 1은 갈 수 있는 길
- **특징**:
    - 캐릭터는 동, 서, 남, 북으로 한 칸씩 이동 가능
    - 맵을 벗어나는 이동은 불가능
    - 시작점은 항상 (1,1), 상대 팀 진영은 (n,m)
    - n = 1, m = 1인 경우는 없음

#### **2. 해결 아이디어**

- **그래프 탐색**: 게임 맵을 2D 격자 그래프로 간주. 각 칸은 노드, 이동 가능한 방향은 간선
- **네트워크 식별**: 시작점에서 상대 팀 진영까지의 최단 경로 길이를 찾거나, 경로가 없음을 확인
- **알고리즘 선택**:
    - BFS: 최단 경로를 보장하며, 격자 그래프에서 레벨 단위로 탐색하므로 적합
    - DFS는 모든 경로를 탐색하므로 최단 경로를 찾는 데 비효율적

#### **3. 핵심 로직**

1. **큐 초기화**: 시작점 (0,0)을 큐에 삽입하고, 해당 위치의 거리를 1로 설정(maps 배열에 직접 기록)
2. **BFS 탐색**:
    - 큐에서 현재 좌표를 꺼내 동, 서, 남, 북 방향으로 이동 시도
    - 이동 가능한 조건: 맵 범위 내, 벽이 아님(maps[i][j] = 1), 아직 방문하지 않음
    - 유효한 이동이면 해당 좌표를 큐에 추가하고, 거리를 현재 거리 + 1로 갱신
3. **종료 조건**:
    - 상대 팀 진영(n-1, m-1)에 도달하면 해당 위치의 거리 반환
    - 큐가 비었는데도 도달하지 못하면 -1 반환
4. **방문 관리**: 별도의 방문 배열 대신 maps 배열에 거리를 기록하며 방문 여부 관리

#### **4. 입출력 예 분석**

- **예제 1**: maps = `[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]]`
    - 시작: (1,1), 목표: (5,5)
    - 경로: (1,1) → (1,3) → (1,4) → (1,5) → (2,5) → (3,5) → (3,4) → (3,3) → (4,3) → (4,4) → (5,5).
    - 결과: 11칸.
- **예제 2**: maps = `[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]]`
    - 목표 (5,5)에 도달 불가능(벽으로 막힘).
    - 결과: -1.

#### **5. 코드 설계**

- **변수**:
    - queue: BFS를 위한 큐(좌표와 거리 저장).
    - maps: 입력 맵을 거리 기록용으로 활용.
    - dx, dy: 동, 서, 남, 북 이동을 위한 방향 배열.
- **BFS 함수**:
    - 입력: maps, 맵 크기(n, m).
    - 동작: 시작점부터 큐를 활용해 탐색, 목표 도달 시 거리 반환.
- **메인 로직**:
    - 시작점 초기화 후 BFS 실행.
    - 목표 도달 여부에 따라 거리 또는 -1 반환.

#### **6. 코드 구현**

```python
from collections import deque

def solution(maps):
    n, m = len(maps), len(maps[0])
    dx = [1, -1, 0, 0] 
    dy = [0, 0, 1, -1]
    
    queue = deque([(0, 0)])
    maps[0][0] = 1 
    
    while queue:
        x, y = queue.popleft()
        
        if x == n-1 and y == m-1:
            return maps[x][y]
    
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            
            if 0 <= nx < n and 0 <= ny < m and maps[nx][ny] == 1:
                queue.append((nx, ny))
                maps[nx][ny] = maps[x][y] + 1
    
    return -1
```