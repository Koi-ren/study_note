# 너비 우선 탐색이란?
- BFS(너비 우선 탐색)는 시작 노드로부터 가까운 노드부터 순서대로 방문하는 알고리즘이다. 
- 즉, 거리가 1인 노드를 모두 방문한 후 거리가 2, 3인 노드로 차례로 넘어간다. 
	- 이는 큐를 사용해 구현되며, 최단 경로 탐색에 유리하다. 
- 반면, DFS(깊이 우선 탐색)는 시작 노드에서 한 경로를 따라 끝까지 탐색한 후, 다른 경로로 돌아가며 노드를 방문한다. 
	- 이는 스택이나 재귀를 사용해 구현된다 
	- 그래프의 모든 경로를 탐색하거나 사이클을 찾는 데 유용하다. 
- 따라서 BFS는 레벨 단위로 넓게 탐색하고, DFS는 한 경로를 깊게 파고드는 점에서 다르다.
# 개념 문제

## 1. BFS(너비 우선 탐색) 알고리즘의 작동 원리와 자료구조

- **작동 원리**:
    - 시작 노드에서 출발해 인접 노드를 모두 탐색한 뒤, 다음 단계의 인접 노드를 순차적으로 탐색
    - 레벨 단위로 탐색 진행(즉, 시작 노드로부터 거리가 가까운 노드부터 방문)
    - 탐색 과정:
        1. 시작 노드를 큐에 삽입하고 방문 표시
        2. 큐에서 노드를 꺼내 그 인접 노드를 방문
        3. 방문하지 않은 인접 노드를 큐에 삽입하고 방문 표시
        4. 큐가 빌 때까지 반복
- **사용 자료구조**: 큐(Queue)
    - 이유: BFS는 먼저 방문한 노드의 인접 노드를 우선 처리해야 하므로, 선입선출 방식의 큐가 적합
	    - 큐는 노드를 레벨 순서대로 유지하며, 새로운 노드를 뒤에 추가하고 오래된 노드를 앞에서 꺼내 처리
    - 추가적으로, 방문 여부를 확인하기 위해 집합(Set)이나 배열을 사용
- **왜 큐인가?**: 큐는 노드의 방문 순서를 시작점에서 가까운 순서대로 보장하며, 스택(DFS에서 사용)과 달리 깊이 우선이 아닌 너비 우선 탐색을 가능하게 함

## 2. BFS와 DFS의 차이점 및 적합한 문제

- **차이점**:
    - **탐색 방식**:
        - BFS: 너비 우선 탐색. 같은 레벨의 노드를 모두 탐색 후 다음 레벨로 이동
	        - 큐 사용
        - DFS: 깊이 우선 탐색. 한 경로를 끝까지 탐색 후 다른 경로로 이동 
	        - 스택 또는 재귀 사용
	    - ![[빈출유형 스터디 2주차-20250412.png]]
    - **메모리 사용**:
        - BFS: 큐에 같은 레벨의 노드를 저장하므로, 넓은 그래프에서 메모리 사용량이 많을 수 있음
        - DFS: 스택(또는 재귀 호출 스택)에 현재 경로만 저장하므로, 깊은 그래프에서 메모리 효율적
    - **완전성**:
        - BFS: 유한 그래프에서 목표 노드를 반드시 찾음(최단 경로 보장)
        - DFS: 무한 그래프나 사이클이 있는 경우 목표를 놓칠 가능성 있음
- **적합한 문제**:
    - **BFS**:
        - 적합: 최단 경로 찾기, 레벨 기반 탐색
        - 예시: 미로에서 시작점에서 출구까지의 최단 경로 찾기
	        1. 다익스트라 알고리즘의 기초 형태 
		        -  네트워크에서 특정 노드까지의 최소 홉 수 계산
	        2. 소셜 네트워크에서 친구 관계 레벨 분석
    - **DFS**:
        - 적합: 모든 경로 탐색, 연결성 확인, 백트래킹
        - 그래프에서 사이클 존재 여부 판별
	        1. 방문 중 노드 재방문 시 사이클 확인
	        2. 스도쿠나 N-퀸 문제처럼 모든 가능한 해를 탐색하는 경우
- **비교**:

| BFS               | DFS                        |
| ----------------- | -------------------------- |
| 최단 경로가 중요한 문제에 적합 | 메모리 효율적이고 완전 탐색이 필요한 경우 유리 |


## 3. BFS 시간 복잡도와 그래프 형태의 영향

- **시간 복잡도**: BFS의 시간 복잡도는 O(V + E)
    - V: 정점(Vertex) 수
	    - 각 정점을 한 번씩 방문
    - E: 간선(Edge) 수 
	    - 각 간선을 한 번씩 확인
    - 큐 연산(삽입/삭제)은 O(1)이므로, 전체 복잡도는 정점과 간선 처리에 의해 결정
- **그래프 형태의 영향**:
    - **밀집 그래프(Dense Graph)**:
        - 특징: 간선 수가 정점 수의 제곱에 가까움(E ≈ V², 예: 완전 그래프)
        - 영향: 간선 확인 비용이 지배적. 시간 복잡도는 O(V²)에 가까워짐
        - 예시: 인접 행렬로 표현된 그래프에서, 각 정점의 인접 노드 확인 시 O(V) 걸리므로, 총 O(V²)
        - 실제 수행 시간: 간선이 많아 큐에 삽입되는 노드 수가 많고, 각 노드의 인접 리스트 탐색에 시간이 더 걸림
    - **희소 그래프(Sparse Graph)**:
        - 특징: 간선 수가 정점 수에 비해 적음(E ≈ V, 예: 트리나 격자 그래프)
        - 영향: 정점과 간선 수가 비슷한 비율로 기여. 시간 복잡도는 O(V + E) ≈ O(V)
        - 예시: 인접 리스트로 표현된 그래프에서, 각 정점의 인접 노드 확인 비용이 적음
        - 실제 수행 시간: 간선이 적어 큐에 삽입되는 노드 수가 적고, 인접 노드 탐색이 빠름
- **결론**: 
	- 밀집 그래프에서는 간선 처리로 인해 실제 수행 시간이 증가 
	- 희소 그래프에서는 정점 처리 비중이 커 상대적으로 빠름
	- 그래프 표현 방식(인접 리스트 vs 인접 행렬)도 수행 시간에 큰 영향을 미침
		- 인접 리스트는 희소 그래프에서 효율적, 인접 행렬은 밀집 그래프에서 유리

# 풀어볼 문제
## 1. 너비 우선 탐색 순회
...
## 2. 게임 맵 최단거리
### **문제:**

[코딩테스트 연습 - 게임 맵 최단거리 | 프로그래머스 스쿨](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

### **2번 문제 해결 핵심 정리**

#### **1. 문제 이해**

- **목표**: 주어진 게임 맵에서 캐릭터가 시작점(1,1)에서 상대 팀 진영(n,m)까지의 최단 경로(칸 수)를 구함 
	- 경로가 없으면 -1 반환
- **입력**:
    - maps: n × m 크기의 2차원 배열 (1 ≤ n, m ≤ 100)
    - maps[i][j] = 0은 벽, 1은 갈 수 있는 길
- **특징**:
    - 캐릭터는 동, 서, 남, 북으로 한 칸씩 이동 가능
    - 맵을 벗어나는 이동은 불가능
    - 시작점은 항상 (1,1), 상대 팀 진영은 (n,m)
    - n = 1, m = 1인 경우는 없음

#### **2. 해결 아이디어**

- **그래프 탐색**: 게임 맵을 2D 격자 그래프로 간주. 각 칸은 노드, 이동 가능한 방향은 간선
- **네트워크 식별**: 시작점에서 상대 팀 진영까지의 최단 경로 길이를 찾거나, 경로가 없음을 확인
- **알고리즘 선택**:
    - BFS: 최단 경로를 보장하며, 격자 그래프에서 레벨 단위로 탐색하므로 적합
    - DFS는 모든 경로를 탐색하므로 최단 경로를 찾는 데 비효율적

#### **3. 핵심 로직**

1. **큐 초기화**: 시작점 (0,0)을 큐에 삽입하고, 해당 위치의 거리를 1로 설정(maps 배열에 직접 기록)
2. **BFS 탐색**:
    - 큐에서 현재 좌표를 꺼내 동, 서, 남, 북 방향으로 이동 시도
    - 이동 가능한 조건: 맵 범위 내, 벽이 아님(maps[i][j] = 1), 아직 방문하지 않음
    - 유효한 이동이면 해당 좌표를 큐에 추가하고, 거리를 현재 거리 + 1로 갱신
3. **종료 조건**:
    - 상대 팀 진영(n-1, m-1)에 도달하면 해당 위치의 거리 반환
    - 큐가 비었는데도 도달하지 못하면 -1 반환
4. **방문 관리**: 별도의 방문 배열 대신 maps 배열에 거리를 기록하며 방문 여부 관리

#### **4. 입출력 예 분석**

- **예제 1**: maps = `[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]]`
    - 시작: (1,1), 목표: (5,5)
    - 경로: (1,1) → (1,3) → (1,4) → (1,5) → (2,5) → (3,5) → (3,4) → (3,3) → (4,3) → (4,4) → (5,5)
    - 결과: 11칸
- **예제 2**: maps = `[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]]`
    - 목표 (5,5)에 도달 불가능
    - 결과: -1

#### **5. 코드 설계**

- **변수**:
    - queue: BFS를 위한 큐(좌표와 거리 저장)
    - maps: 입력 맵을 거리 기록용으로 활용
    - dx, dy: 동, 서, 남, 북 이동을 위한 방향 배열
- **BFS 함수**:
    - 입력: maps, 맵 크기(n, m)
    - 동작: 시작점부터 큐를 활용해 탐색, 목표 도달 시 거리 반환
- **메인 로직**:
    - 시작점 초기화 후 BFS 실행
    - 목표 도달 여부에 따라 거리 또는 -1 반환

#### **6. 코드 구현**

```python
from collections import deque

def solution(maps):
    n, m = len(maps), len(maps[0])
    dx = [1, -1, 0, 0] 
    dy = [0, 0, 1, -1]
    
    queue = deque([(0, 0)])
    maps[0][0] = 1 
    
    while queue:
        x, y = queue.popleft()
        
        if x == n-1 and y == m-1:
            return maps[x][y]
    
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            
            if 0 <= nx < n and 0 <= ny < m and maps[nx][ny] == 1:
                queue.append((nx, ny))
                maps[nx][ny] = maps[x][y] + 1
    
    return -1
```

## 3. 경주로 건설

### **문제:**
[코딩테스트 연습 - 경주로 건설 | 프로그래머스 스쿨](https://school.programmers.co.kr/learn/courses/30/lessons/67259)

### **2번 문제 해결 핵심 정리**

#### **1. 문제 이해**

- **목표**: N × N 격자 맵에서 출발점(0,0)에서 도착점(N-1,N-1)까지 경주로를 건설하는 최소 비용을 계산. 직선 도로 100원, 코너 500원 추가
- **입력**:
    - board: N × N 크기의 2차원 배열 (3 ≤ N ≤ 25)
    - board[i][j] = 0은 빈 칸(도로 건설 가능), 1은 벽(도로 건설 불가능)
- **특징**:
    - 출발점(0,0)과 도착점(N-1,N-1)은 항상 0
    - 이동은 상, 하, 좌, 우로 가능하며, 벽은 통과 불가
    - 비용: 직선 도로 100원, 코너(방향 전환) 500원 추가
    - 경로가 항상 존재함

#### **2. 해결 아이디어**

- **그래프 탐색**: 격자 맵을 그래프로 간주. 각 칸은 노드, 상하좌우 이동은 간선
- **네트워크 식별**: 출발점에서 도착점까지 최소 비용 경로를 찾음. 코너로 인한 비용 증가를 방향별로 관리
- **알고리즘 선택**:
    - BFS: 고정된 비용(100원/600원)을 기반으로 최단 경로를 찾기에 적합. 방향별 비용을 큐로 관리
    - 다익스트라도 가능하나 BFS로 충분
    - DFS는 모든 경로를 탐색하므로 비효율적

#### **3. 핵심 로직**

1. **큐 초기화**: 시작점(0,0)을 큐에 삽입. 초기 방향은 없으므로 첫 이동은 직선 비용(100원)만 부과
2. **BFS 탐색**:
    - 큐에서 현재 좌표(x, y), 방향(dir), 비용(cost)을 꺼냄
    - 상, 하, 좌, 우로 이동 시도:
        - 맵 범위 내, 벽이 아닌 경우 이동 가능
        - 비용 계산:
            - 첫 이동(x=0, y=0인 상태에서 이동): 직선 비용(100원)
            - 이후 이동:
                - 동일 방향: 직선 비용(100원)
                - 직각 방향: 직선(100원) + 코너(500원) = 600원
        - 새 좌표의 해당 방향 비용이 더 작거나 같으면 갱신 후 큐 추가(같은 비용도 추가하여 모든 경로 탐색)
3. **비용 관리**: 각 칸마다 4방향(상, 하, 좌, 우)별 최소 비용을 3D 배열로 저장
4. **종료 조건**: 도착점(N-1, N-1)의 4방향 비용 중 유효한 최소값 반환

#### **4. 입출력 예 분석**

- **예제 1**: board = `[[0,0,0],[0,0,0],[0,0,0]]`
    - 경로: (0,0) → (0,1) → (0,2) → (1,2) → (2,2)
    - 비용: 직선 4개(400원) + 코너 1개(500원) = 900원
- **예제 2**: board =` [[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]]`
    - 경로: 직선 18개 + 코너 4개
    - 비용: 18 × 100 + 4 × 500 = 3800원
- **예제 3**: board = `[[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]]`
    - 경로: 직선 6개 + 코너 3개
    - 비용: 6 × 100 + 3 × 500 = 2100원
- **예제 4**: board = `[[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]]`
    - 경로: 직선 12개 + 코너 4개
    - 비용: 12 × 100 + 4 × 500 = 3200원

#### **5. 코드 설계**

- **변수**:
    - queue: BFS 큐(좌표, 방향, 비용)
    - costs: 방향별 최소 비용(N × N × 4)
    - dx, dy: 상, 하, 좌, 우 이동 방향
- **BFS 함수**:
    - 입력: board, 맵 크기(N)
    - 동작: 시작점부터 탐색, 방향별 최소 비용 갱신
- **메인 로직**:
    - 시작점에서 첫 이동 처리(코너 비용 제외)
    - BFS로 도착점의 최소 비용 계산
    - 도착점 비용 중 유효한 값만 반환

#### **6. 코드 구현**

```python
from collections import deque

def solution(board):
    N = len(board)
    dx = [-1, 1, 0, 0] 
    dy = [0, 0, -1, 1]
    costs = [[[float('inf')] * 4 for _ in range(N)] for _ in range(N)] 
       
    queue = deque([(0, 0, -1, 0)])  
    costs[0][0] = [0, 0, 0, 0]  
    
    while queue:
        x, y, dir, cost = queue.popleft()
        
        for next_dir in range(4):
            nx, ny = x + dx[next_dir], y + dy[next_dir]
            
            if 0 <= nx < N and 0 <= ny < N and board[nx][ny] == 0:
                new_cost = cost + 100  
                if dir != -1 and dir != next_dir:  
                    new_cost += 500
            
                if new_cost <= costs[nx][ny][next_dir]:
                    costs[nx][ny][next_dir] = new_cost
                    queue.append((nx, ny, next_dir, new_cost))
    
    min_cost = min(costs[N-1][N-1])
    return min_cost if min_cost != float('inf') else 0 
```