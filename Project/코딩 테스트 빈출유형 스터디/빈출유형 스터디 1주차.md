# 개념 문제

## 1. DFS 구현 방식 비교 (재귀 호출 vs 명시적 스택)

- **재귀 호출**:
    - **장점**: 코드가 간결하고 직관적, 스택 관리 필요 없음(시스템 호출 스택 활용)
    - **단점**: 깊은 그래프에서 스택 오버플로우 발생 가능, 메모리 사용량 제어 어려움
- **명시적 스택**:
    - **장점**: 메모리 사용량 직접 제어 가능, 스택 오버플로우 위험 없음, 깊은 그래프 처리 유리
    - **단점**: 코드가 복잡하고 구현 시간 더 걸림, 스택 관리 직접 해야 함
- **비교**: 재귀는 간단한 문제에 적합, 스택은 대규모 데이터나 안정성이 중요한 경우 유리

## 2. 방향 그래프에서 사이클 판별 (DFS 활용)

- **알고리즘**:
    1. 각 노드에 대해 방문 상태를 기록(미방문, 방문 중, 방문 완료)
    2. DFS로 그래프 탐색 시작:
        - 노드를 방문 중으로 표시
        - 인접 노드 탐색 중 이미 "방문 중"인 노드 만나면 사이클 존재
        - 탐색 끝나면 "방문 완료"로 표시
    3. 모든 노드에 대해 반복, 사이클 여부 확인
- **핵심**: "방문 중" 상태에서 같은 노드 재방문 시 사이클 판별
- **구체적 예**: A → B → C → A 탐색 중 C에서 A로 가는 간선 발견 시 사이클 확인

## 3. 재귀 DFS에서 백트래킹 동작 설명

- **동작 방식**: 재귀 호출로 노드를 방문하며 더 이상 갈 곳 없으면 최근 노드로 돌아감(호출 스택 pop)
- **예시**:
    - 그래프: A → B → D, A → C
    - 과정:
        1. A 방문 → B 방문 → D 방문
        2. D에서 갈 곳 없음 → B로 백트래킹
        3. B에서 더 탐색할 곳 없음 → A로 백트래킹
        4. A에서 C 방문 후 종료
    - **결과**: 백트래킹은 호출 스택을 통해 자연스럽게 이전 노드로 복귀하며 경로 탐색

## 개념 문제 참고 블로그: 
- [[Data Structure / Algorithms] Cycle Detection in Graphs (사이클 판별)](https://velog.io/@jeon0976/Data-Structure-Algorithms-Cycle-Detection-in-Graphs-%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%8C%90%EB%B3%84)
- [[알고리즘] DFS/BFS/재귀함수/Stack](https://velog.io/@sugenius77/DFSBFS%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98Stack)

# 풀어볼 문제

## 1. 깊이 우선 탐색 문제(몸풀이)
## 2. 네트워크(프로그래머스)

### **문제:** 
[코딩테스트 연습 - 네트워크 | 프로그래머스 스쿨](https://school.programmers.co.kr/learn/courses/30/lessons/43162)
### **2번 문제 해결 핵심 정리**

#### **1. 문제 이해**

- **목표**: 주어진 컴퓨터 연결 정보에서 독립된 네트워크 개수를 구함
- **입력**:
    - n: 컴퓨터 개수 (1 ≤ n ≤ 200)
    - computers: n × n 크기의 2차원 배열, computers[i][j] = 1이면 i와 j가 연결됨
- **특징**:
    - computers[i][i] = 1 (자기 자신은 항상 연결)
    - 연결은 양방향(무방향 그래프)으로 간주 가능

#### **2. 해결 아이디어**

- **그래프 탐색**: 각 컴퓨터를 노드로, 연결을 간선으로 간주해 그래프를 구성
- **네트워크 식별**: 연결된 컴퓨터 그룹(네트워크)을 탐색으로 묶고, 독립된 그룹 수를 셈
- **알고리즘 선택**:
    - DFS: 한 노드에서 시작해 연결된 모든 노드를 재귀로 방문
    - BFS: 큐를 활용해 인접 노드를 순차적으로 방문
    - 둘 중 하나 선택 가능(여기선 DFS로 설명)

#### **3. 핵심 로직**

1. **방문 여부 체크**: 각 컴퓨터의 방문 상태를 기록할 배열(visited) 생성
2. **DFS 구현**:
    - 시작 노드 방문 표시 후, 연결된 모든 노드를 재귀적으로 탐색
    - 한 네트워크 내 모든 노드 방문 완료 시 종료
3. **네트워크 개수 세기**:
    - 방문하지 않은 노드를 발견할 때마다 DFS 실행 → 네트워크 수 증가
4. **반복**: 모든 노드 방문할 때까지 진행

#### **4. 입출력 예 분석**

- **예제 1**: n = 3, computers = `[[1, 1, 0], [1, 1, 0], [0, 0, 1]]
    - 네트워크 1: 0번 ↔ 1번
    - 네트워크 2: 2번
    - 결과: 2개
- **예제 2**: n = 3, computers = `[[1, 1, 0], [1, 1, 1], [0, 1, 1]]
    - 네트워크 1: 0번 ↔ 1번 ↔ 2번
    - 결과: 1개

#### **5. 코드 설계**

- **변수**:
    - visited: 방문 여부 배열 (초기값: False)
    - count: 네트워크 개수
- **DFS 함수**:
    - 입력: 현재 노드, computers, visited
    - 동작: 연결된노드 탐색 후 방문 표시
- **메인 로직**:
    - 모든 노드 순회하며 방문 안 된 노드 발견 시 DFS 호출, count 증가

#### **6. 코드 구현**

```python
def solution(n, computers):
    visited = [False] * n
    answer = 0
    
    def dfs(com):
        visited[com] = True
        for neighbor in range(n):
            if neighbor != com and computers[com][neighbor] == 1 and not visited[neighbor]:
                dfs(neighbor)
    
    for com in range(n):
        if not visited[com]:
            dfs(com)
            answer += 1
    
    return answer
```

## 3. 양과 늑대(프로그래머스)
### **문제:** 
[코딩테스트 연습 - 양과 늑대 | 프로그래머스 스쿨](https://school.programmers.co.kr/learn/courses/30/lessons/92343)
#### **1. 문제 이해**

- **목표**: 이진 트리에서 양을 최대한 많이 모으되, 늑대 수가 양 수보다 적게 유지하며 루트로 돌아오기
- **입력**:
    - info: 각 노드의 양(0) 또는 늑대(1) 정보 배열 (2 ≤ 길이 ≤ 17)
    - edges: 부모-자식 노드 연결 정보 2차원 배열 (행 길이 = info 길이 - 1, 열 길이 = 2)
- **특징**:
    - 루트 노드(0번)는 항상 양(0)이며, 이진 트리 구조로 주어짐
    - 양 수 < 늑대 수일 경우 실패, 방문 경로에서 조건을 만족해야 함

#### **2. 해결 아이디어**

- **그래프 탐색**: 이진 트리를 그래프로 보고, DFS로 가능한 모든 경로 탐색
- **네트워크 식별**: 방문 가능한 노드 집합을 동적으로 관리하며 양과 늑대 수를 추적
- **알고리즘 선택**:
    - DFS: 상태(양 수, 늑대 수, 방문 가능 노드)를 재귀적으로 탐색
    - 각 노드 방문 시 양/늑대 수를 갱신하며 최대 양 수 계산

#### **3. 핵심 로직**

1. **트리 구조 변환**: edges를 인접 리스트로 변환해 각 노드의 자식 노드 관리
2. **DFS 구현**:
    - 현재 상태: 양 수(sheep), 늑대 수(wolves), 방문 가능 노드 집합(available)
    - 조건 체크: sheep > wolves일 때만 진행
    - 현재 노드 방문 후, 자식 노드를 available에 추가
    - 모든 가능한 다음 노드에 대해 재귀 호출
3. **최대값 갱신**: 각 경로에서 sheep 값을 비교해 최대값 저장
4. **반복**: 모든 가능한 경로 탐색하며 최대 양 수 계산

#### **4. 입출력 예 분석**

- **예제 1**: info = `[0,0,1,1,1,0,1,0,1,0,1,1]`, edges = `[[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]]`
    - 경로 예: 0(양1) → 1(양2) → 8(양2,늑1) → 7(양3,늑1) → 9(양4,늑1) → 5(양5,늑1)
    - 결과: 5
- **예제 2**: info = `[0,1,0,1,1,0,1,0,0,1,0]`, edges = `[[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]]`
    - 경로 예: 0(양1) → 2(양2) → 5(양3) → 6(양3,늑1) → 8(양4,늑1) → 10(양5,늑1)
    - 결과: 5

#### **5. 코드 설계**

- **변수**:
    - graph: 인접 리스트로 변환된 트리 (각 노드의 자식 노드 리스트)
    - max_sheep: 최대 양 수 저장
- **DFS 함수**:
    - 입력: 현재 노드(node), 양 수(sheep), 늑대 수(wolves), 방문 가능 노드 집합(available), info, graph
    - 동작: 조건 확인 후 양/늑대 수 갱신, 자식 노드 추가, 다음 노드 재귀 탐색
- **메인 로직**:
    - graph 생성 후, 0번 노드에서 DFS 시작

#### **6. 코드 구현**

```python
def solution(info, edges):
    answer = 0
    
    graph = [[] for _ in range(len(info))]
    for parent, child in edges:
        graph[parent].append(child)
    
    def dfs(node, sheep, wolves, available):
        nonlocal answer
        
        if info[node] == 0:
            sheep += 1
        else:
            wolves += 1
        
        answer = max(answer, sheep)
        
        if wolves >= sheep:
            return
        
        next_available = available | set(graph[node])
        next_available.discard(node)
        
        for next_node in next_available:
            dfs(next_node, sheep, wolves, next_available)

    dfs(0, 0, 0, {0})
    
    return answer
```