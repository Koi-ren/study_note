# 3.2 운동학 알고리즘
운동학 이동 알고리즘(Kinematic movement algorithm)은 정적인 데이터(위치, 방위)를 사용하고 원하는 속도를 결과값으로 내뱉는다

결과값은 보통 참/거짓 형태이거나 목표 방향, 최대 속도로 이동 또는 정지 상태로 있기 등이다

속도의 급격한 변화는 여러 프레임에 걸쳐 부드럽게 될 수 있지만 운동학 알고리즘은 가속도를 사용하지 않는다

이동 알고리즘 - [[위치, 방위의 갱신]]이 목표 속도를 반환하고 나면 방향을 설정하기 위해 사용된다
```의사 결정 코드
function newOrientation(current: float, velocity: Vector) -> float:
	if velocity.length() > 0:
	# 속도로 부터 방위 값을 결정한다.
		return atan2(-static.x,static.z)
	else:
		return current
```

위 의사 코드를 파이썬 코드로 구현하면 다음과 같다

```python
import math

class Vector:
    def __init__(self, x, z):
        self.x = x
        self.z = z

    def length(self):
        return math.sqrt(self.x**2 + self.z**2)

def newOrientation(current, velocity, static):
    if velocity.length() > 0:
        # 속도를 기반으로 새로운 방향 계산
        return math.atan2(-static.x, static.z)
    else:
        # 기존 방향 유지
        return current
```


# 3.2.1 찾기
- 찾기 행동은 입력으로 캐릭터와 목표물의 정적인 데이터를 사용한다
- 캐릭터에서 목표물을 향하는 방향을 계산하고 이 라인을 따르는 속도를 요구한다
- 방위 값은 보통 생략되지만 newOrientation 함수를 사용해 이동하는 방향으로 얼굴의 방향을 바꿀 수 있다

```의사 코드
class KinematicSeek:
	character: Static
	target: Static

	maxSpeed: float

	function getSteering(): -> KinematicSteeringOutput:
		result = new KinematicsSteeringOutput()

		# 목표로의 방향을 얻는다
		result.velocity = target.position - character.position
		# 속도는 이 방향으로 최대 스피드로 설정한다
		result.velocity.normalize()
		result.velocity *= maxSpeed

		character.orientation = newOrientation(
			character.orientation,
			result.velocity)

		result.ratation = 0
		return result
```

위 의사 코드를 파이썬 코드로 구현하면 다음과 같다

```python
import math

# newOrientation 함수 정의
def newOrientation(current, velocity):
    if velocity.length() > 0:
        return math.atan2(-velocity.x, velocity.y)
    else:
        return current

# 기존 Vector 클래스에 normalize 메서드 추가
class Vector:
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    def length(self):
        return math.sqrt(self.x**2 + self.y**2)

    def normalize(self):
        length = self.length()
        if length > 0:
            self.x /= length
            self.y /= length

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# KinematicSteeringOutput 클래스
class KinematicSteeringOutput:
    def __init__(self, velocity=Vector(), rotation=0.0):
        self.velocity = velocity
        self.rotation = rotation

# KinematicSeek 클래스
class KinematicSeek:
    def __init__(self, character, target, maxSpeed):
        self.character = character
        self.target = target
        self.maxSpeed = maxSpeed

    def getSteering(self):
        result = KinematicSteeringOutput()

        # 목표로의 방향 계산
        result.velocity = self.target.position - self.character.position
        result.velocity.normalize()  # 방향 벡터 정규화
        result.velocity *= self.maxSpeed  # 최대 속도 설정

        # 새로운 방위 계산
        self.character.orientation = newOrientation(
            self.character.orientation,
            result.velocity
        )

        result.rotation = 0
        return result
```

### **성능**
- 이 알고리즘은 시각과 공간 복잡도 모두 O(1) 이다

### **도망가기**
캐릭터가 목표물로부터 도망가게 하고 싶다면 getSteering 함수의 두 번째 라인을 반대 방향으로 향하게 하면 된다
```의사 코드
# 목표로 부터 멀어지는 방향을 얻는다
steering.velocity = character.position - target.position
```

파이썬도 마찬가지로 반대 순서로 계산해주면 된다

```python
result.velocity = self.character.position - self.target.position
```
### **도착하기**
앞서 본 알고리즘은 캐릭터를 추적하는데 사용하나 문제가 있다.
Ex_1) 캐릭터가 목표 지점까지 최대 속도로 진입 후 갑자기 멈추는 경우
Ex_2) 캐릭터가 목표 지점에 도착 못하고 지나쳐 그 인근을 서성이다 도착하는 경우

- 이에 대한 해결 방법
	1. 목표 위치에 큰 반지름을 설정, 이 반지름 안에 진입 시 도착이라 간주
	2. 목표 지점의 거리에 따른 속도 조절

아쉽게도 두 번째 방법은 캐릭터가 목표 지점에 완벽하게 도착하지 못할 경우 그 인근을 서성이는 문제가 발생

따라서 두 가지 방법을 섞어서 사용
속도를 조절할 수 있으면 더 작은 반지름 사용 가능

찾기 알고리즘을 수정해 캐릭터가 정해진 반지름 범위에 있는지 체크할 수 있고 범위 안에 있으면 아무런 동작을 필요로 하지 않는다

만약 캐릭터가 범위 바깥에 있다면 고정 시간으로 목표 지점까지 이동시킨다

```의사 코드
class KinematicArrive:
	character: Static
	target: Static

	maxSpeed: float

	# 충족하는 반경
	radius: float

	# 목표 지점까지의 상수 시간
	timeToTarget: float = 0.25

	function getSteering() -> KinematicSteeringOutput:
		result = new KinematicSteeringOutput()

		# 목표물로의 방향을 구한다
		reslut.velocity = target.position - character.position
		
		# 우리가 범위 안에 있는지 체크
		if result.velocity.length() < radius:
			# 스티어링을 요구하지 않음
			return null

		# 타깃으로 이동하며 timeToTarget 시간 안에 도착한다
		result.velocity /= timeToTarget

		if result.velocity.length > maxSpeed:
			result.velocity.normalize()
			result.velocity *= maxSpeed

		# 이동하는 쪽으로 바라본다
		character.orientation = newOrientation(
			character.orientation,
			result.velocity)

		# 출력
		result.rotation = 0
		return result
```

위 코드를 파이썬으로 구현하면 다음과 같다

```python
import math

# KinematicSteeringOutput 클래스
class KinematicSteeringOutput:
    def __init__(self, velocity=None, rotation=0.0):
        self.velocity = velocity if velocity else Vector()
        self.rotation = rotation

# Vector 클래스
class Vector:
    def __init__(self, x=0.0, y=0.0):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        return Vector(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)

    def length(self):
        return math.sqrt(self.x**2 + self.y**2)

    def normalize(self):
        length = self.length()
        if length > 0:
            self.x /= length
            self.y /= length

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

# newOrientation 함수
def newOrientation(current, velocity):
    if velocity.length() > 0:
        return math.atan2(-velocity.x, velocity.y)
    else:
        return current

# KinematicArrive 클래스
class KinematicArrive:
    def __init__(self, character, target, maxSpeed, radius, timeToTarget=0.25):
        self.character = character
        self.target = target
        self.maxSpeed = maxSpeed
        self.radius = radius
        self.timeToTarget = timeToTarget

    def getSteering(self):
        result = KinematicSteeringOutput()

        # 목표물로의 방향 계산
        result.velocity = self.target.position - self.character.position
        
        # 범위 안에 있는지 체크
        if result.velocity.length() < self.radius:
            # 목표물 근처에 있을 경우 스티어링 필요 없음
            return None

        # 타깃으로 이동하며 시간 내 도착 설정
        result.velocity *= (1 / self.timeToTarget)

        # 최대 속도 제한
        if result.velocity.length() > self.maxSpeed:
            result.velocity.normalize()
            result.velocity *= self.maxSpeed

        # 이동하는 쪽으로 바라보기
        self.character.orientation = newOrientation(
            self.character.orientation,
            result.velocity
        )

        result.rotation = 0
        return result

class Kinematic:
    def __init__(self, position=None, orientation=0.0):
        self.position = position if position else Vector()
        self.orientation = orientation
```